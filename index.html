<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <script src="https://unpkg.com/react@17.0.2/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.26.0/babel.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .App {
            text-align: center;
        }
        h1 {
            color: #333;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const INITIAL_BOARD = [
            ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
            ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
            ...Array(4).fill(Array(8).fill('')),
            ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
            ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
        ];

        const isWhitePiece = (piece) => '♔♕♖♗♘♙'.includes(piece);
        const isBlackPiece = (piece) => '♚♛♜♝♞♟'.includes(piece);

        const isValidPawnMove = (startRow, startCol, endRow, endCol, piece, board) => {
            const isWhitePawn = piece === '♙';
            const direction = isWhitePawn ? -1 : 1;
            const startingRow = isWhitePawn ? 6 : 1;

            // Move one square forward
            if (startCol === endCol && endRow === startRow + direction && !board[endRow][endCol]) {
                return true;
            }

            // Move two squares forward from starting position
            if (startCol === endCol && startRow === startingRow && endRow === startRow + 2 * direction
                && !board[startRow + direction][startCol] && !board[endRow][endCol]) {
                return true;
            }

            // Capture diagonally
            if (Math.abs(startCol - endCol) === 1 && endRow === startRow + direction) {
                const targetPiece = board[endRow][endCol];
                return targetPiece && isWhitePawn !== isWhitePiece(targetPiece);
            }

            return false;
        };

        const isValidKnightMove = (startRow, startCol, endRow, endCol) => {
            const rowDiff = Math.abs(endRow - startRow);
            const colDiff = Math.abs(endCol - startCol);
            return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
        };

        const isValidBishopMove = (startRow, startCol, endRow, endCol, board) => {
            const rowDiff = Math.abs(endRow - startRow);
            const colDiff = Math.abs(endCol - startCol);

            // Check if the move is diagonal
            if (rowDiff !== colDiff) {
                return false;
            }

            // Determine the direction of movement
            const rowDirection = endRow > startRow ? 1 : -1;
            const colDirection = endCol > startCol ? 1 : -1;

            // Check if the path is clear
            for (let i = 1; i < rowDiff; i++) {
                const row = startRow + i * rowDirection;
                const col = startCol + i * colDirection;
                if (board[row][col] !== '') {
                    return false; // Path is blocked
                }
            }

            return true;
        };
        
        

        const isValidRookMove = (startRow, startCol, endRow, endCol, board) => {
            // Check if the move is either horizontal or vertical
            if (startRow !== endRow && startCol !== endCol) {
                return false;
            }

            // Determine the direction of movement
            const rowDirection = startRow === endRow ? 0 : (endRow > startRow ? 1 : -1);
            const colDirection = startCol === endCol ? 0 : (endCol > startCol ? 1 : -1);

            // Check if the path is clear
            let currentRow = startRow + rowDirection;
            let currentCol = startCol + colDirection;

            while (currentRow !== endRow || currentCol !== endCol) {
                if (board[currentRow][currentCol] !== '') {
                    return false; // Path is blocked
                }
                currentRow += rowDirection;
                currentCol += colDirection;
            }

            return true;
        };
        
        const isValidQueenMove = (startRow, startCol, endRow, endCol, board) => {
            // Queen moves are valid if they're either valid rook moves or valid bishop moves
            return isValidRookMove(startRow, startCol, endRow, endCol, board) ||
                   isValidBishopMove(startRow, startCol, endRow, endCol, board);
        };
        
        const isSquareUnderAttack = (row, col, board, attackingColor) => {
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece && (attackingColor === 'white' ? isWhitePiece(piece) : isBlackPiece(piece))) {
                        let isAttacking = false;
                        switch(piece) {
                            case '♙':
                            case '♟':
                                // Pawns attack diagonally forward
                                const direction = attackingColor === 'white' ? -1 : 1;
                                isAttacking = (Math.abs(j - col) === 1 && i + direction === row);
                                break;
                            case '♘':
                            case '♞':
                                isAttacking = isValidKnightMove(i, j, row, col);
                                break;
                            case '♗':
                            case '♝':
                                isAttacking = isValidBishopMove(i, j, row, col, board);
                                break;
                            case '♖':
                            case '♜':
                                isAttacking = isValidRookMove(i, j, row, col, board);
                                break;
                            case '♕':
                            case '♛':
                                isAttacking = isValidQueenMove(i, j, row, col, board);
                                break;
                            case '♔':
                            case '♚':
                                // King can attack adjacent squares
                                isAttacking = isValidKingMove(i, j, row, col);
                                break;
                        }
                        if (isAttacking) return true;
                    }
                }
            }
            return false;
        };

        // The rest of the component remains the same

        const isValidKingMove = (startRow, startCol, endRow, endCol, board, kingColor) => {
            const rowDiff = Math.abs(endRow - startRow);
            const colDiff = Math.abs(endCol - startCol);
            
            // King can move one square in any direction
            const isBasicMoveValid = (rowDiff <= 1 && colDiff <= 1) && (rowDiff + colDiff > 0);

            if (!isBasicMoveValid) return false;

            // Check if the destination square is under attack
            const oppositeColor = kingColor === 'white' ? 'black' : 'white';
            return !isSquareUnderAttack(endRow, endCol, board, oppositeColor);
        };

        const getLegalMoves = (piece, row, col, board) => {
            const legalMoves = [];
            const isWhite = isWhitePiece(piece);

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const targetPiece = board[i][j];
                    
                    // Check if the destination square is occupied by a piece of the same color
                    if (targetPiece && isWhite === isWhitePiece(targetPiece)) {
                        continue;
                    }

                    let isLegalMove = false;

                    switch(piece) {
                        case '♙':
                        case '♟':
                            isLegalMove = isValidPawnMove(row, col, i, j, piece, board);
                            break;
                        case '♘':
                        case '♞':
                            isLegalMove = isValidKnightMove(row, col, i, j);
                            break;
                        case '♗':
                        case '♝':
                            isLegalMove = isValidBishopMove(row, col, i, j, board);
                            break;
                        case '♖':
                        case '♜':
                            isLegalMove = isValidRookMove(row, col, i, j, board);
                            break;
                        case '♕':
                        case '♛':
                            isLegalMove = isValidQueenMove(row, col, i, j, board);
                            break;
                        case '♔':
                        case '♚':
                            isLegalMove = isValidKingMove(row, col, i, j, board, isWhite ? 'white' : 'black');
                            break;
                    }

                    if (isLegalMove) {
                        legalMoves.push([i, j]);
                    }
                }
            }
            return legalMoves;
        };

        // ... (rest of the Chessboard component remains the same)
        
        const ChessSquare = ({ piece, isLight, isSelected, isLegalMove, onClick }) => (
            <div
                onClick={onClick}
                style={{
                    width: '50px',
                    height: '50px',
                    backgroundColor: isSelected ? '#7bccf7' : isLegalMove ? '#90EE90' : (isLight ? '#f0d9b5' : '#b58863'),
                    display: 'flex',
                    justifyContent: 'center',
                    alignItems: 'center',
                    cursor: 'pointer',
                    fontSize: '2rem',
                }}
            >
                {piece}
            </div>
        );

        const Chessboard = () => {
            const [board, setBoard] = React.useState(INITIAL_BOARD);
            const [selectedPiece, setSelectedPiece] = React.useState(null);
            const [legalMoves, setLegalMoves] = React.useState([]);
            const [currentPlayer, setCurrentPlayer] = React.useState('white');
            const [status, setStatus] = React.useState("White's turn to move");

            const handleSquareClick = (row, col) => {
                if (selectedPiece) {
                    const { piece, row: startRow, col: startCol } = selectedPiece;
                    const isLegalMove = legalMoves.some(move => move[0] === row && move[1] === col);

                    if (isLegalMove) {
                        const newBoard = board.map(r => [...r]);
                        newBoard[startRow][startCol] = '';
                        newBoard[row][col] = piece;
                        setBoard(newBoard);
                        setCurrentPlayer(currentPlayer === 'white' ? 'black' : 'white');
                        setStatus(`${currentPlayer === 'white' ? "Black" : "White"}'s turn to move`);
                    }

                    setSelectedPiece(null);
                    setLegalMoves([]);
                } else if (board[row][col]) {
                    const piece = board[row][col];
                    const isCurrentPlayerPiece =
                        (currentPlayer === 'white' && isWhitePiece(piece)) ||
                        (currentPlayer === 'black' && isBlackPiece(piece));

                    if (isCurrentPlayerPiece) {
                        setSelectedPiece({ piece, row, col });
                        setLegalMoves(getLegalMoves(piece, row, col, board));
                    } else {
                        setStatus(`It's ${currentPlayer}'s turn. Please select a ${currentPlayer} piece.`);
                    }
                }
            };

            return (
                <div>
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(8, 50px)',
                        gridTemplateRows: 'repeat(8, 50px)',
                        width: '400px',
                        height: '400px',
                        border: '4px solid #333',
                        margin: '20px auto'
                    }}>
                        {board.map((row, rowIndex) =>
                            row.map((piece, colIndex) => (
                                <ChessSquare
                                    key={`${rowIndex}-${colIndex}`}
                                    piece={piece}
                                    isLight={(rowIndex + colIndex) % 2 === 0}
                                    isSelected={selectedPiece && selectedPiece.row === rowIndex && selectedPiece.col === colIndex}
                                    isLegalMove={legalMoves.some(move => move[0] === rowIndex && move[1] === colIndex)}
                                    onClick={() => handleSquareClick(rowIndex, colIndex)}
                                />
                            ))
                        )}
                    </div>
                    <div style={{ textAlign: 'center', marginTop: '10px', fontSize: '18px' }}>
                        {status}
                    </div>
                </div>
            );
        };

        function App() {
            return (
                <div className="App">
                    <h1>Chess Game</h1>
                    <Chessboard />
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
